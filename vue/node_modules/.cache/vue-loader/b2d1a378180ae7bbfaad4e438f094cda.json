{"remainingRequest":"/Users/mia/Documents/wxypapp/Vue-shopping/vue/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js??vue-loader-options!/Users/mia/Documents/wxypapp/Vue-shopping/vue/src/components/my/Cropper.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/mia/Documents/wxypapp/Vue-shopping/vue/src/components/my/Cropper.vue","mtime":1554103443655},{"path":"/Users/mia/Documents/wxypapp/Vue-shopping/vue/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mia/Documents/wxypapp/Vue-shopping/vue/node_modules/_babel-loader@8.0.5@babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/mia/Documents/wxypapp/Vue-shopping/vue/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mia/Documents/wxypapp/Vue-shopping/vue/node_modules/_vue-loader@15.7.0@vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n\nimport Cropper from \"cropperjs\";\nexport default {\n  props: {\n    imgStyle: {\n      //裁剪后的图像显示\n      type: Object,\n      default: {\n        width: \"50px\",\n        height: \"50px\",\n        \"border-radius\": \"50%\"\n      }\n    },\n    // 定义的宽高比\n    widthRate: {\n      type: Number,\n      default: 500\n    },\n    // 定义的宽高比\n    heightRate: {\n      type: Number,\n      default: 500\n    },\n    imgUrl: {\n      type: String,\n      default: function() {\n        return \"\";\n      }\n    }\n  },\n  data() {\n    return {};\n  },\n  mounted() {\n   \n  },\n  methods: {\n    change(event) {\n      let image = document.getElementById(\"img\"); //预览对象\n      this.clip(event, {\n        resultObj: image,\n        aspectWithRatio: Number(this.widthRate),\n        aspectHeightRatio: Number(this.heightRate)\n      });\n    },\n    //初始化方法\n    initilize(opt) {\n      let self = this;\n      this.options = opt;\n      //创建dom\n      this.createElement();\n      this.resultObj = opt.resultObj;\n      //初始化裁剪对象\n      this.cropper = new Cropper(this.preview, {\n        aspectRatio: opt.aspectWithRatio / opt.aspectHeightRatio,\n        // aspectRatio: 1/1,\n        autoCropArea: opt.autoCropArea || 0.8,\n        viewMode: 2,\n        guides: true,\n        cropBoxResizable: true, //是否通过拖动来调整剪裁框的大小\n        cropBoxMovable: true, //是否通过拖拽来移动剪裁框。\n        dragCrop: false,\n        dragMode: \"move\", //‘crop’: 可以产生一个新的裁剪框3 ‘move’: 只可以移动3 ‘none’: 什么也不处理\n        center: true,\n        zoomable: true, //是否允许放大图像。\n        zoomOnTouch: true, //是否可以通过拖动触摸来放大图像。\n        scalable: true,\n        // minCropBoxHeight: 750,\n        // minCropBoxWidth: 750,\n        background: false,\n        checkOrientation: true,\n        checkCrossOrigin: true,\n        zoomable: false,\n        zoomOnWheel: false,\n        center: false,\n        toggleDragModeOnDblclick: false,\n        ready: function() {\n          // console.log(self.cropper.rotate(90))\n          if (opt.aspectRatio == \"Free\") {\n            let cropBox = self.cropper.cropBox;\n            cropBox.querySelector(\"span.cropper-view-box\").style.outline =\n              \"none\";\n            self.cropper.disable();\n          }\n        }\n      });\n    },\n    //创建一些必要的DOM，用于图片裁剪\n    createElement() {\n      //初始化图片为空对象\n      this.preview = null;\n      // <img src=\"../../assets/app/loading.gif\">\n      let str =\n        '<div><img id=\"clip_image\" src=\"originUrl\"></div><button type=\"button\" id=\"cancel_clip\">取消</button><button type=\"button\" id=\"clip_button\">确定</button>';\n      str +=\n        '<div class=\"crop_loading\"><div class=\"crop_content\"><div class=\"crop_text\">图片修剪中...</div></div></div>';\n      str +=\n        '<div class=\"crop_success\"><div class=\"crop_success_text\">上传成功</div></div></div>';\n\n      //   let body = document.getElementsByTagName('body')[0];\n      let app = document.getElementById(\"setAvatar\");\n      this.reagion = document.createElement(\"div\");\n      this.reagion.id = \"clip_container\";\n      this.reagion.className = \"container\";\n      this.reagion.innerHTML = str;\n      //添加创建好的DOM元素\n      app.appendChild(this.reagion);\n      this.preview = document.getElementById(\"clip_image\");\n\n      //绑定一些方法\n      this.initFunction();\n    },\n    //初始化一些函数绑定\n    initFunction() {\n      let self = this;\n      this.clickBtn = document.getElementById(\"clip_button\");\n      this.cancelBtn = document.getElementById(\"cancel_clip\");\n      //确定事件\n      this.addEvent(this.clickBtn, \"click\", function() {\n        self.crop();\n      });\n      //取消事件\n      this.addEvent(this.cancelBtn, \"click\", function() {\n        self.destoried();\n      });\n      //清空input的值\n      this.addEvent(this.fileObj, \"click\", function() {\n        this.value = \"\";\n      });\n    },\n    //外部接口，用于input['file']对象change时的调用\n    clip(e, opt) {\n      let self = this;\n\n      this.fileObj = e.srcElement;\n\n      let files = e.target.files || e.dataTransfer.files;\n\n      if (!files.length) return false; //不是图片直接返回\n\n      //调用初始化方法\n      this.initilize(opt);\n\n      //获取图片文件资源\n      this.picValue = files[0];\n\n      console.log(this.picValue);\n\n      //调用方法转成url格式\n      this.originUrl = this.getObjectURL(this.picValue);\n\n      //每次替换图片要重新得到新的url\n      if (this.cropper) {\n        this.cropper.replace(this.originUrl);\n      }\n    },\n    //图片转码方法\n    getObjectURL(file) {\n      let url = null;\n      if (window.createObjectURL != undefined) {\n        // basic\n        url = window.createObjectURL(file);\n      } else if (window.URL != undefined) {\n        // mozilla(firefox)\n        url = window.URL.createObjectURL(file);\n      } else if (window.webkitURL != undefined) {\n        // webkit or chrome\n        url = window.webkitURL.createObjectURL(file);\n      }\n      return url;\n    },\n    //点击确定进行裁剪\n    crop() {\n      let self = this;\n      let image = new Image();\n      let croppedCanvas;\n      let roundedCanvas;\n\n      // Crop\n      document.querySelector(\".crop_loading\").style.display = \"block\";\n\n      setTimeout(function() {\n        croppedCanvas = self.cropper.getCroppedCanvas();\n        // Round\n        roundedCanvas = self.getRoundedCanvas(croppedCanvas);\n\n        let imgData = roundedCanvas.toDataURL();\n        image.src = imgData;\n\n        //判断图片是否大于100k,不大于直接上传，反之压缩\n        if (imgData.length < 100 * 1024) {\n          self.resultObj.src = imgData;\n          //图片上传\n          self.postImg(imgData);\n        } else {\n          image.onload = function() {\n            //压缩处理\n            let data = self.compress(image, self.Orientation);\n            self.resultObj.src = data;\n            //图片上传\n            self.postImg(data);\n          };\n        }\n      }, 20);\n    },\n    //获取裁剪图片资源\n    getRoundedCanvas(sourceCanvas) {\n      let canvas = document.createElement(\"canvas\");\n      let context = canvas.getContext(\"2d\");\n      let width = sourceCanvas.width;\n      let height = sourceCanvas.height;\n\n      canvas.width = width;\n      canvas.height = height;\n\n      context.imageSmoothingEnabled = true;\n      context.drawImage(sourceCanvas, 0, 0, width, height);\n      context.globalCompositeOperation = \"destination-in\";\n      context.beginPath();\n      context.rect(0, 0, width, height);\n      context.fill();\n\n      return canvas;\n    },\n    //销毁原来的对象\n    destoried() {\n      let self = this;\n      //移除事件\n      this.removeEvent(this.clickBtn, \"click\", null);\n      this.removeEvent(this.cancelBtn, \"click\", null);\n      this.removeEvent(this.fileObj, \"click\", null);\n      //移除裁剪框\n      this.reagion.parentNode.removeChild(this.reagion);\n\n      //销毁裁剪对象\n      this.cropper.destroy();\n      this.cropper = null;\n    },\n    //图片上传\n    postImg(imageData) {\n      // console.log(imageData)\n\n      this.$emit(\"callback\", imageData);\n      //这边写图片的上传\n      let self = this;\n      self.destoried();\n\n      // window.setTimeout( function () {\n      //   document.querySelector('.crop_loading').style.display = 'none';\n      //   document.querySelector('.crop_success').style.display = 'block';\n      //   //裁剪完后摧毁对象\n      //     self.destoried();\n      // },3000)\n    },\n    //图片旋转\n    rotateImg(img, direction, canvas) {\n      //最小与最大旋转方向，图片旋转4次后回到原方向\n      const min_step = 0;\n      const max_step = 3;\n      if (img == null) return;\n      //img的高度和宽度不能在img元素隐藏后获取，否则会出错\n      let height = img.height;\n      let width = img.width;\n      let step = 2;\n      if (step == null) {\n        step = min_step;\n      }\n      if (direction == \"right\") {\n        step++;\n        //旋转到原位置，即超过最大值\n        step > max_step && (step = min_step);\n      } else {\n        step--;\n        step < min_step && (step = max_step);\n      }\n      //旋转角度以弧度值为参数\n      let degree = (step * 90 * Math.PI) / 180;\n      let ctx = canvas.getContext(\"2d\");\n      switch (step) {\n        case 0:\n          canvas.width = width;\n          canvas.height = height;\n          ctx.drawImage(img, 0, 0);\n          break;\n        case 1:\n          canvas.width = height;\n          canvas.height = width;\n          ctx.rotate(degree);\n          ctx.drawImage(img, 0, -height);\n          break;\n        case 2:\n          canvas.width = width;\n          canvas.height = height;\n          ctx.rotate(degree);\n          ctx.drawImage(img, -width, -height);\n          break;\n        case 3:\n          canvas.width = height;\n          canvas.height = width;\n          ctx.rotate(degree);\n          ctx.drawImage(img, -width, 0);\n          break;\n      }\n    },\n    //图片压缩\n    compress(img, Orientation) {\n      let canvas = document.createElement(\"canvas\");\n      let ctx = canvas.getContext(\"2d\");\n      //瓦片canvas\n      let tCanvas = document.createElement(\"canvas\");\n      let tctx = tCanvas.getContext(\"2d\");\n      let initSize = img.src.length;\n      let width = img.width;\n      let height = img.height;\n\n      //如果图片大于四百万像素，计算压缩比并将大小压至400万以下\n      let ratio;\n      if ((ratio = (width * height) / 4000000) > 1) {\n        console.log(\"大于400万像素\");\n        ratio = Math.sqrt(ratio);\n        width /= ratio;\n        height /= ratio;\n      } else {\n        ratio = 1;\n      }\n      canvas.width = width;\n      canvas.height = height;\n      //        铺底色\n      ctx.fillStyle = \"#fff\";\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      //如果图片像素大于100万则使用瓦片绘制\n      let count;\n      if ((count = (width * height) / 1000000) > 1) {\n        count = ~~(Math.sqrt(count) + 1); //计算要分成多少块瓦片\n        //            计算每块瓦片的宽和高\n        let nw = ~~(width / count);\n        let nh = ~~(height / count);\n        tCanvas.width = nw;\n        tCanvas.height = nh;\n        for (let i = 0; i < count; i++) {\n          for (let j = 0; j < count; j++) {\n            tctx.drawImage(\n              img,\n              i * nw * ratio,\n              j * nh * ratio,\n              nw * ratio,\n              nh * ratio,\n              0,\n              0,\n              nw,\n              nh\n            );\n            ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);\n          }\n        }\n      } else {\n        ctx.drawImage(img, 0, 0, width, height);\n      }\n      //修复ios上传图片的时候 被旋转的问题\n      if (Orientation != \"\" && Orientation != 1) {\n        switch (Orientation) {\n          case 6: //需要顺时针（向左）90度旋转\n            this.rotateImg(img, \"left\", canvas);\n            break;\n          case 8: //需要逆时针（向右）90度旋转\n            this.rotateImg(img, \"right\", canvas);\n            break;\n          case 3: //需要180度旋转\n            this.rotateImg(img, \"right\", canvas); //转两次\n            this.rotateImg(img, \"right\", canvas);\n            break;\n        }\n      }\n      //进行最小压缩\n      // let ndata = canvas.toDataURL( 'image/jpeg' , 0.1);\n      let ndata = canvas.toDataURL(\"image/png\", 0.1);\n      console.log(\"压缩前：\" + initSize);\n      console.log(\"压缩后：\" + ndata.length);\n      console.log(\n        \"压缩率：\" + ~~((100 * (initSize - ndata.length)) / initSize) + \"%\"\n      );\n      tCanvas.width = tCanvas.height = canvas.width = canvas.height = 0;\n\n      return ndata;\n    },\n    //添加事件\n    addEvent(obj, type, fn) {\n      if (obj.addEventListener) {\n        obj.addEventListener(type, fn, false);\n      } else {\n        obj.attachEvent(\"on\" + type, fn);\n      }\n    },\n    //移除事件\n    removeEvent(obj, type, fn) {\n      if (obj.removeEventListener) {\n        obj.removeEventListener(type, fn, false);\n      } else {\n        obj.detachEvent(\"on\" + type, fn);\n      }\n    }\n  }\n};\n",{"version":3,"sources":["Cropper.vue"],"names":[],"mappings":";;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Cropper.vue","sourceRoot":"src/components/my","sourcesContent":["<template>\n<!-- 图片裁剪 -->\n  <div class=\"vue-box\">\n    <img :src=\"imgUrl\" alt id=\"img\" :style=\"imgStyle\">\n    <input type=\"file\" class=\"file\"  accept=\"image/*\"  @change=\"change($event)\">\n  </div>\n</template>\n<script>\nimport Cropper from \"cropperjs\";\nexport default {\n  props: {\n    imgStyle: {\n      //裁剪后的图像显示\n      type: Object,\n      default: {\n        width: \"50px\",\n        height: \"50px\",\n        \"border-radius\": \"50%\"\n      }\n    },\n    // 定义的宽高比\n    widthRate: {\n      type: Number,\n      default: 500\n    },\n    // 定义的宽高比\n    heightRate: {\n      type: Number,\n      default: 500\n    },\n    imgUrl: {\n      type: String,\n      default: function() {\n        return \"\";\n      }\n    }\n  },\n  data() {\n    return {};\n  },\n  mounted() {\n   \n  },\n  methods: {\n    change(event) {\n      let image = document.getElementById(\"img\"); //预览对象\n      this.clip(event, {\n        resultObj: image,\n        aspectWithRatio: Number(this.widthRate),\n        aspectHeightRatio: Number(this.heightRate)\n      });\n    },\n    //初始化方法\n    initilize(opt) {\n      let self = this;\n      this.options = opt;\n      //创建dom\n      this.createElement();\n      this.resultObj = opt.resultObj;\n      //初始化裁剪对象\n      this.cropper = new Cropper(this.preview, {\n        aspectRatio: opt.aspectWithRatio / opt.aspectHeightRatio,\n        // aspectRatio: 1/1,\n        autoCropArea: opt.autoCropArea || 0.8,\n        viewMode: 2,\n        guides: true,\n        cropBoxResizable: true, //是否通过拖动来调整剪裁框的大小\n        cropBoxMovable: true, //是否通过拖拽来移动剪裁框。\n        dragCrop: false,\n        dragMode: \"move\", //‘crop’: 可以产生一个新的裁剪框3 ‘move’: 只可以移动3 ‘none’: 什么也不处理\n        center: true,\n        zoomable: true, //是否允许放大图像。\n        zoomOnTouch: true, //是否可以通过拖动触摸来放大图像。\n        scalable: true,\n        // minCropBoxHeight: 750,\n        // minCropBoxWidth: 750,\n        background: false,\n        checkOrientation: true,\n        checkCrossOrigin: true,\n        zoomable: false,\n        zoomOnWheel: false,\n        center: false,\n        toggleDragModeOnDblclick: false,\n        ready: function() {\n          // console.log(self.cropper.rotate(90))\n          if (opt.aspectRatio == \"Free\") {\n            let cropBox = self.cropper.cropBox;\n            cropBox.querySelector(\"span.cropper-view-box\").style.outline =\n              \"none\";\n            self.cropper.disable();\n          }\n        }\n      });\n    },\n    //创建一些必要的DOM，用于图片裁剪\n    createElement() {\n      //初始化图片为空对象\n      this.preview = null;\n      // <img src=\"../../assets/app/loading.gif\">\n      let str =\n        '<div><img id=\"clip_image\" src=\"originUrl\"></div><button type=\"button\" id=\"cancel_clip\">取消</button><button type=\"button\" id=\"clip_button\">确定</button>';\n      str +=\n        '<div class=\"crop_loading\"><div class=\"crop_content\"><div class=\"crop_text\">图片修剪中...</div></div></div>';\n      str +=\n        '<div class=\"crop_success\"><div class=\"crop_success_text\">上传成功</div></div></div>';\n\n      //   let body = document.getElementsByTagName('body')[0];\n      let app = document.getElementById(\"setAvatar\");\n      this.reagion = document.createElement(\"div\");\n      this.reagion.id = \"clip_container\";\n      this.reagion.className = \"container\";\n      this.reagion.innerHTML = str;\n      //添加创建好的DOM元素\n      app.appendChild(this.reagion);\n      this.preview = document.getElementById(\"clip_image\");\n\n      //绑定一些方法\n      this.initFunction();\n    },\n    //初始化一些函数绑定\n    initFunction() {\n      let self = this;\n      this.clickBtn = document.getElementById(\"clip_button\");\n      this.cancelBtn = document.getElementById(\"cancel_clip\");\n      //确定事件\n      this.addEvent(this.clickBtn, \"click\", function() {\n        self.crop();\n      });\n      //取消事件\n      this.addEvent(this.cancelBtn, \"click\", function() {\n        self.destoried();\n      });\n      //清空input的值\n      this.addEvent(this.fileObj, \"click\", function() {\n        this.value = \"\";\n      });\n    },\n    //外部接口，用于input['file']对象change时的调用\n    clip(e, opt) {\n      let self = this;\n\n      this.fileObj = e.srcElement;\n\n      let files = e.target.files || e.dataTransfer.files;\n\n      if (!files.length) return false; //不是图片直接返回\n\n      //调用初始化方法\n      this.initilize(opt);\n\n      //获取图片文件资源\n      this.picValue = files[0];\n\n      console.log(this.picValue);\n\n      //调用方法转成url格式\n      this.originUrl = this.getObjectURL(this.picValue);\n\n      //每次替换图片要重新得到新的url\n      if (this.cropper) {\n        this.cropper.replace(this.originUrl);\n      }\n    },\n    //图片转码方法\n    getObjectURL(file) {\n      let url = null;\n      if (window.createObjectURL != undefined) {\n        // basic\n        url = window.createObjectURL(file);\n      } else if (window.URL != undefined) {\n        // mozilla(firefox)\n        url = window.URL.createObjectURL(file);\n      } else if (window.webkitURL != undefined) {\n        // webkit or chrome\n        url = window.webkitURL.createObjectURL(file);\n      }\n      return url;\n    },\n    //点击确定进行裁剪\n    crop() {\n      let self = this;\n      let image = new Image();\n      let croppedCanvas;\n      let roundedCanvas;\n\n      // Crop\n      document.querySelector(\".crop_loading\").style.display = \"block\";\n\n      setTimeout(function() {\n        croppedCanvas = self.cropper.getCroppedCanvas();\n        // Round\n        roundedCanvas = self.getRoundedCanvas(croppedCanvas);\n\n        let imgData = roundedCanvas.toDataURL();\n        image.src = imgData;\n\n        //判断图片是否大于100k,不大于直接上传，反之压缩\n        if (imgData.length < 100 * 1024) {\n          self.resultObj.src = imgData;\n          //图片上传\n          self.postImg(imgData);\n        } else {\n          image.onload = function() {\n            //压缩处理\n            let data = self.compress(image, self.Orientation);\n            self.resultObj.src = data;\n            //图片上传\n            self.postImg(data);\n          };\n        }\n      }, 20);\n    },\n    //获取裁剪图片资源\n    getRoundedCanvas(sourceCanvas) {\n      let canvas = document.createElement(\"canvas\");\n      let context = canvas.getContext(\"2d\");\n      let width = sourceCanvas.width;\n      let height = sourceCanvas.height;\n\n      canvas.width = width;\n      canvas.height = height;\n\n      context.imageSmoothingEnabled = true;\n      context.drawImage(sourceCanvas, 0, 0, width, height);\n      context.globalCompositeOperation = \"destination-in\";\n      context.beginPath();\n      context.rect(0, 0, width, height);\n      context.fill();\n\n      return canvas;\n    },\n    //销毁原来的对象\n    destoried() {\n      let self = this;\n      //移除事件\n      this.removeEvent(this.clickBtn, \"click\", null);\n      this.removeEvent(this.cancelBtn, \"click\", null);\n      this.removeEvent(this.fileObj, \"click\", null);\n      //移除裁剪框\n      this.reagion.parentNode.removeChild(this.reagion);\n\n      //销毁裁剪对象\n      this.cropper.destroy();\n      this.cropper = null;\n    },\n    //图片上传\n    postImg(imageData) {\n      // console.log(imageData)\n\n      this.$emit(\"callback\", imageData);\n      //这边写图片的上传\n      let self = this;\n      self.destoried();\n\n      // window.setTimeout( function () {\n      //   document.querySelector('.crop_loading').style.display = 'none';\n      //   document.querySelector('.crop_success').style.display = 'block';\n      //   //裁剪完后摧毁对象\n      //     self.destoried();\n      // },3000)\n    },\n    //图片旋转\n    rotateImg(img, direction, canvas) {\n      //最小与最大旋转方向，图片旋转4次后回到原方向\n      const min_step = 0;\n      const max_step = 3;\n      if (img == null) return;\n      //img的高度和宽度不能在img元素隐藏后获取，否则会出错\n      let height = img.height;\n      let width = img.width;\n      let step = 2;\n      if (step == null) {\n        step = min_step;\n      }\n      if (direction == \"right\") {\n        step++;\n        //旋转到原位置，即超过最大值\n        step > max_step && (step = min_step);\n      } else {\n        step--;\n        step < min_step && (step = max_step);\n      }\n      //旋转角度以弧度值为参数\n      let degree = (step * 90 * Math.PI) / 180;\n      let ctx = canvas.getContext(\"2d\");\n      switch (step) {\n        case 0:\n          canvas.width = width;\n          canvas.height = height;\n          ctx.drawImage(img, 0, 0);\n          break;\n        case 1:\n          canvas.width = height;\n          canvas.height = width;\n          ctx.rotate(degree);\n          ctx.drawImage(img, 0, -height);\n          break;\n        case 2:\n          canvas.width = width;\n          canvas.height = height;\n          ctx.rotate(degree);\n          ctx.drawImage(img, -width, -height);\n          break;\n        case 3:\n          canvas.width = height;\n          canvas.height = width;\n          ctx.rotate(degree);\n          ctx.drawImage(img, -width, 0);\n          break;\n      }\n    },\n    //图片压缩\n    compress(img, Orientation) {\n      let canvas = document.createElement(\"canvas\");\n      let ctx = canvas.getContext(\"2d\");\n      //瓦片canvas\n      let tCanvas = document.createElement(\"canvas\");\n      let tctx = tCanvas.getContext(\"2d\");\n      let initSize = img.src.length;\n      let width = img.width;\n      let height = img.height;\n\n      //如果图片大于四百万像素，计算压缩比并将大小压至400万以下\n      let ratio;\n      if ((ratio = (width * height) / 4000000) > 1) {\n        console.log(\"大于400万像素\");\n        ratio = Math.sqrt(ratio);\n        width /= ratio;\n        height /= ratio;\n      } else {\n        ratio = 1;\n      }\n      canvas.width = width;\n      canvas.height = height;\n      //        铺底色\n      ctx.fillStyle = \"#fff\";\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      //如果图片像素大于100万则使用瓦片绘制\n      let count;\n      if ((count = (width * height) / 1000000) > 1) {\n        count = ~~(Math.sqrt(count) + 1); //计算要分成多少块瓦片\n        //            计算每块瓦片的宽和高\n        let nw = ~~(width / count);\n        let nh = ~~(height / count);\n        tCanvas.width = nw;\n        tCanvas.height = nh;\n        for (let i = 0; i < count; i++) {\n          for (let j = 0; j < count; j++) {\n            tctx.drawImage(\n              img,\n              i * nw * ratio,\n              j * nh * ratio,\n              nw * ratio,\n              nh * ratio,\n              0,\n              0,\n              nw,\n              nh\n            );\n            ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);\n          }\n        }\n      } else {\n        ctx.drawImage(img, 0, 0, width, height);\n      }\n      //修复ios上传图片的时候 被旋转的问题\n      if (Orientation != \"\" && Orientation != 1) {\n        switch (Orientation) {\n          case 6: //需要顺时针（向左）90度旋转\n            this.rotateImg(img, \"left\", canvas);\n            break;\n          case 8: //需要逆时针（向右）90度旋转\n            this.rotateImg(img, \"right\", canvas);\n            break;\n          case 3: //需要180度旋转\n            this.rotateImg(img, \"right\", canvas); //转两次\n            this.rotateImg(img, \"right\", canvas);\n            break;\n        }\n      }\n      //进行最小压缩\n      // let ndata = canvas.toDataURL( 'image/jpeg' , 0.1);\n      let ndata = canvas.toDataURL(\"image/png\", 0.1);\n      console.log(\"压缩前：\" + initSize);\n      console.log(\"压缩后：\" + ndata.length);\n      console.log(\n        \"压缩率：\" + ~~((100 * (initSize - ndata.length)) / initSize) + \"%\"\n      );\n      tCanvas.width = tCanvas.height = canvas.width = canvas.height = 0;\n\n      return ndata;\n    },\n    //添加事件\n    addEvent(obj, type, fn) {\n      if (obj.addEventListener) {\n        obj.addEventListener(type, fn, false);\n      } else {\n        obj.attachEvent(\"on\" + type, fn);\n      }\n    },\n    //移除事件\n    removeEvent(obj, type, fn) {\n      if (obj.removeEventListener) {\n        obj.removeEventListener(type, fn, false);\n      } else {\n        obj.detachEvent(\"on\" + type, fn);\n      }\n    }\n  }\n};\n</script>\n<style scoped>\n.vue-box {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  min-height: 0.4rem;\n}\n\n.vue-box .file {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  opacity: 0;\n  top: 0;\n  left: 0;\n  z-index: 99;\n  cursor: pointer;\n}\n\nimg {\n  width: 200px;\n  height: 200px;\n  border-radius: 50%;\n}\n\nh3 {\n  text-align: center;\n}\n\nh1,\nh2 {\n  font-weight: normal;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n</style>\n"]}]}